# CI/CD Pipeline for dbbackup
# Main repo: Gitea (git.uuxo.net)
# Mirror: GitHub (github.com/PlusOne/dbbackup)
name: CI/CD

on:
  push:
    branches: [main, master, develop]
    tags: ['v*']
  pull_request:
    branches: [main, master]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -race -coverprofile=coverage.out ./...

      - name: Coverage summary
        run: go tool cover -func=coverage.out | tail -1

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test]
    container:
      image: golang:1.24-bookworm
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports: ['5432:5432']
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: mysql
          MYSQL_DATABASE: testdb
        ports: ['3306:3306']
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates postgresql-client default-mysql-client
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Wait for databases
        run: |
          echo "Waiting for PostgreSQL..."
          for i in $(seq 1 30); do
            pg_isready -h postgres -p 5432 && break || sleep 1
          done
          echo "Waiting for MySQL..."
          for i in $(seq 1 30); do
            mysqladmin ping -h mysql -u root -pmysql --silent && break || sleep 1
          done

      - name: Build dbbackup
        run: go build -o dbbackup .

      - name: Test PostgreSQL backup/restore
        env:
          PGHOST: postgres
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          # Create test data
          psql -h postgres -c "CREATE TABLE test_table (id SERIAL PRIMARY KEY, name TEXT);"
          psql -h postgres -c "INSERT INTO test_table (name) VALUES ('test1'), ('test2'), ('test3');"
          # Run backup
          ./dbbackup backup --engine postgres --host postgres --user postgres --password postgres --database testdb --output /tmp/pg_backup.sql.gz
          # Verify backup file exists
          ls -la /tmp/pg_backup.sql.gz

      - name: Test MySQL backup/restore
        env:
          MYSQL_HOST: mysql
          MYSQL_USER: root
          MYSQL_PASSWORD: mysql
        run: |
          # Create test data
          mysql -h mysql -u root -pmysql testdb -e "CREATE TABLE test_table (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255));"
          mysql -h mysql -u root -pmysql testdb -e "INSERT INTO test_table (name) VALUES ('test1'), ('test2'), ('test3');"
          # Run backup
          ./dbbackup backup --engine mysql --host mysql --user root --password mysql --database testdb --output /tmp/mysql_backup.sql.gz
          # Verify backup file exists
          ls -la /tmp/mysql_backup.sql.gz

      - name: Test verify-locks command
        env:
          PGHOST: postgres
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          ./dbbackup verify-locks --host postgres | tee verify-locks.out
          grep -q 'max_locks_per_transaction' verify-locks.out

  lint:
    name: Lint
    runs-on: ubuntu-latest
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Install and run golangci-lint
        run: |
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.8.0
          golangci-lint run --timeout=5m ./...

  build-and-release:
    name: Build & Release
    runs-on: ubuntu-latest
    needs: [test, lint]
    if: startsWith(github.ref, 'refs/tags/v')
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates curl jq
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Build all platforms
        run: |
          mkdir -p release
          
          # Install cross-compilation tools for CGO
          apt-get update && apt-get install -y -qq gcc-aarch64-linux-gnu
          
          # Linux amd64 (with CGO for SQLite)
          echo "Building linux/amd64 (CGO enabled)..."
          CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-linux-amd64 .
          
          # Linux arm64 (with CGO for SQLite)
          echo "Building linux/arm64 (CGO enabled)..."
          CC=aarch64-linux-gnu-gcc CGO_ENABLED=1 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o release/dbbackup-linux-arm64 .
          
          # Darwin amd64 (no CGO - cross-compile limitation)
          echo "Building darwin/amd64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-darwin-amd64 .
          
          # Darwin arm64 (no CGO - cross-compile limitation)
          echo "Building darwin/arm64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -ldflags="-s -w" -o release/dbbackup-darwin-arm64 .
          
          # FreeBSD amd64 (no CGO - cross-compile limitation)
          echo "Building freebsd/amd64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=freebsd GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-freebsd-amd64 .
          
          echo "All builds complete:"
          ls -lh release/

      - name: Create Gitea Release
        env:
          GITEA_TOKEN: ${{ github.token }}
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          
          echo "Creating Gitea release for ${TAG}..."
          echo "Debug: GITHUB_REPOSITORY=${GITHUB_REPOSITORY}"
          echo "Debug: TAG=${TAG}"
          
          # Simple body without special characters
          BODY="Download binaries for your platform"
          
          # Create release via API with simple inline JSON
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token ${GITEA_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{"tag_name":"'"${TAG}"'","name":"'"${TAG}"'","body":"'"${BODY}"'","draft":false,"prerelease":false}' \
            "https://git.uuxo.net/api/v1/repos/${GITHUB_REPOSITORY}/releases")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY_RESPONSE=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Code: $HTTP_CODE"
          echo "Response: $BODY_RESPONSE"
          
          RELEASE_ID=$(echo "$BODY_RESPONSE" | jq -r '.id')
          
          if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
            echo "Failed to create release"
            exit 1
          fi
          
          echo "Created release ID: $RELEASE_ID"
          
          # Upload each binary
          echo "Files to upload:"
          ls -la release/
          
          for file in release/dbbackup-*; do
            FILENAME=$(basename "$file")
            echo "Uploading $FILENAME..."
            UPLOAD_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${GITEA_TOKEN}" \
              -F "attachment=@${file}" \
              "https://git.uuxo.net/api/v1/repos/${GITHUB_REPOSITORY}/releases/${RELEASE_ID}/assets?name=${FILENAME}")
            echo "Upload response: $UPLOAD_RESPONSE"
          done
          
          echo "Gitea release complete!"
          echo "GitHub mirror complete!"