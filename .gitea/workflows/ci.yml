# CI/CD Pipeline for dbbackup
# Main repo: Gitea (git.uuxo.net)
# Mirror: GitHub (github.com/PlusOne/dbbackup)
name: CI/CD

on:
  push:
    branches: [main, master, develop]
    tags: ['v*']
  pull_request:
    branches: [main, master]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -race -coverprofile=coverage.out ./...

      - name: Coverage summary
        run: go tool cover -func=coverage.out | tail -1

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test]
    container:
      image: golang:1.24-bookworm
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        ports: ['5432:5432']
      mysql:
        image: mysql:8
        env:
          MYSQL_ROOT_PASSWORD: mysql
          MYSQL_DATABASE: testdb
        ports: ['3306:3306']
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates postgresql-client default-mysql-client
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Wait for databases
        run: |
          echo "Waiting for PostgreSQL..."
          for i in $(seq 1 30); do
            pg_isready -h postgres -p 5432 && break || sleep 1
          done
          echo "Waiting for MySQL..."
          for i in $(seq 1 30); do
            mysqladmin ping -h mysql -u root -pmysql --silent && break || sleep 1
          done

      - name: Build dbbackup
        run: go build -o dbbackup .

      - name: Test PostgreSQL backup/restore
        env:
          PGHOST: postgres
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          # Create test data with complex types
          psql -h postgres -d testdb -c "
          CREATE TABLE users (
              id SERIAL PRIMARY KEY,
              username VARCHAR(50) NOT NULL,
              email VARCHAR(100) UNIQUE,
              created_at TIMESTAMP DEFAULT NOW(),
              metadata JSONB,
              scores INTEGER[],
              is_active BOOLEAN DEFAULT TRUE
          );
          INSERT INTO users (username, email, metadata, scores) VALUES
          ('alice', 'alice@test.com', '{\"role\": \"admin\"}', '{95, 87, 92}'),
          ('bob', 'bob@test.com', '{\"role\": \"user\"}', '{78, 82, 90}'),
          ('charlie', 'charlie@test.com', NULL, '{100, 95, 98}');
          
          CREATE VIEW active_users AS 
          SELECT username, email, created_at FROM users WHERE is_active = TRUE;
          
          CREATE SEQUENCE test_seq START 1000;
          "
          
          # Test legacy backup
          mkdir -p /tmp/backups
          ./dbbackup backup single testdb --db-type postgres --host postgres --user postgres --backup-dir /tmp/backups --no-config --allow-root
          echo "Legacy backup files:"
          ls -la /tmp/backups/
          
          # Test native engine backup
          mkdir -p /tmp/native-backups
          ./dbbackup backup single testdb --db-type postgres --host postgres --user postgres --backup-dir /tmp/native-backups --native --compression 0 --no-config --allow-root || echo "Native backup failed (expected during development)"
          echo "Native backup files:"
          ls -la /tmp/native-backups/ || echo "No native backups created"
          
          # If native backup succeeded, verify content contains our test data
          if ls /tmp/native-backups/testdb_*.sql 2>/dev/null; then
            echo "Verifying native backup content:"
            cat /tmp/native-backups/testdb_*.sql
            # Check for expected content
            grep -q "users" /tmp/native-backups/testdb_*.sql && echo "✅ Contains users table" || echo "❌ Missing users table"
            grep -q "active_users" /tmp/native-backups/testdb_*.sql && echo "✅ Contains active_users view" || echo "❌ Missing active_users view"
            grep -q "alice" /tmp/native-backups/testdb_*.sql && echo "✅ Contains user data" || echo "❌ Missing user data"
          fi

      - name: Test MySQL backup/restore
        env:
          MYSQL_HOST: mysql
          MYSQL_USER: root
          MYSQL_PASSWORD: mysql
        run: |
          # Create test data with complex types
          mysql -h mysql -u root -pmysql testdb -e "
          CREATE TABLE orders (
              id INT AUTO_INCREMENT PRIMARY KEY,
              customer_name VARCHAR(100) NOT NULL,
              total DECIMAL(10,2),
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              notes TEXT,
              status ENUM('pending', 'processing', 'completed') DEFAULT 'pending',
              is_priority BOOLEAN DEFAULT FALSE,
              binary_data VARBINARY(255)
          );
          INSERT INTO orders (customer_name, total, notes, status, is_priority, binary_data) VALUES
          ('Alice Johnson', 159.99, 'Express shipping', 'processing', TRUE, 0x48656C6C6F),
          ('Bob Smith', 89.50, NULL, 'completed', FALSE, NULL),
          ('Carol Davis', 299.99, 'Gift wrap needed', 'pending', TRUE, 0x546573744461746121);
          
          CREATE VIEW priority_orders AS 
          SELECT customer_name, total, status FROM orders WHERE is_priority = TRUE;
          "
          
          # Test legacy backup
          mkdir -p /tmp/mysql_backups
          ./dbbackup backup single testdb --db-type mysql --host mysql --port 3306 --user root --database testdb --backup-dir /tmp/mysql_backups --no-config --allow-root || echo "Legacy MySQL backup failed"
          echo "Legacy backup files:"
          ls -la /tmp/mysql_backups/ || echo "No legacy backups created"
          
          # Test native engine backup 
          mkdir -p /tmp/mysql-native-backups
          MYSQL_PWD=mysql ./dbbackup backup single testdb --db-type mysql --host mysql --port 3306 --user root --backup-dir /tmp/mysql-native-backups --native --compression 0 --no-config --allow-root || echo "Native MySQL backup failed (expected during development)"
          echo "Native backup files:"
          ls -la /tmp/mysql-native-backups/ || echo "No native backups created"
          
          # If native backup succeeded, verify content
          if ls /tmp/mysql-native-backups/testdb_*.sql 2>/dev/null; then
            echo "Verifying native MySQL backup content:"
            cat /tmp/mysql-native-backups/testdb_*.sql
            # Check for expected content
            grep -q "orders" /tmp/mysql-native-backups/testdb_*.sql && echo "✅ Contains orders table" || echo "❌ Missing orders table"
            grep -q "priority_orders" /tmp/mysql-native-backups/testdb_*.sql && echo "✅ Contains priority_orders view" || echo "❌ Missing priority_orders view"
            grep -q "Alice Johnson" /tmp/mysql-native-backups/testdb_*.sql && echo "✅ Contains order data" || echo "❌ Missing order data"
          fi

      - name: Test verify-locks command
        env:
          PGHOST: postgres
          PGUSER: postgres
          PGPASSWORD: postgres
        run: |
          ./dbbackup verify-locks --host postgres --db-type postgres --no-config --allow-root | tee verify-locks.out
          grep -q 'max_locks_per_transaction' verify-locks.out

  test-native-engines:
    name: Native Engine Tests
    runs-on: ubuntu-latest
    needs: [test]
    container:
      image: golang:1.24-bookworm
    services:
      postgres-native:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: nativetest
          POSTGRES_DB: nativedb
        ports: ['5433:5432']
      mysql-native:
        image: mysql:5.7  # Better compatibility with Go driver
        env:
          MYSQL_ROOT_PASSWORD: nativetest
          MYSQL_DATABASE: nativedb
        ports: ['3307:3306']
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates postgresql-client default-mysql-client
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Wait for databases
        run: |
          echo "Waiting for PostgreSQL on port 5433..."
          for i in $(seq 1 60); do
            pg_isready -h postgres-native -p 5432 && break || sleep 2
          done
          echo "Waiting for MySQL on port 3307..."  
          for i in $(seq 1 60); do
            mysqladmin ping -h mysql-native -u root -pnativetest --silent && break || sleep 2
          done

      - name: Build dbbackup for native testing
        run: go build -o dbbackup-native .

      - name: Test PostgreSQL Native Engine
        env:
          PGPASSWORD: nativetest
        run: |
          echo "=== Setting up PostgreSQL test data ==="
          psql -h postgres-native -U postgres -d nativedb -c "
          CREATE TABLE native_test_users (
              id SERIAL PRIMARY KEY,
              username VARCHAR(50) NOT NULL,
              email VARCHAR(100) UNIQUE,
              created_at TIMESTAMP DEFAULT NOW(),
              metadata JSONB,
              scores INTEGER[],
              is_active BOOLEAN DEFAULT TRUE
          );
          INSERT INTO native_test_users (username, email, metadata, scores) VALUES
          ('test_alice', 'alice@nativetest.com', '{\"role\": \"admin\", \"level\": 5}', '{95, 87, 92}'),
          ('test_bob', 'bob@nativetest.com', '{\"role\": \"user\", \"level\": 2}', '{78, 82, 90, 88}'),
          ('test_carol', 'carol@nativetest.com', NULL, '{100, 95, 98}');
          
          CREATE VIEW native_active_users AS 
          SELECT username, email, created_at FROM native_test_users WHERE is_active = TRUE;
          
          CREATE SEQUENCE native_test_seq START 2000 INCREMENT BY 5;
          
          SELECT 'PostgreSQL native test data created' as status;
          "
          
          echo "=== Testing Native PostgreSQL Backup ==="
          mkdir -p /tmp/pg-native-test
          ./dbbackup-native backup single nativedb \
            --db-type postgres \
            --host postgres-native \
            --port 5432 \
            --user postgres \
            --backup-dir /tmp/pg-native-test \
            --native \
            --compression 0 \
            --no-config \
            --allow-root || true
            
          echo "=== Native PostgreSQL Backup Results ==="
          ls -la /tmp/pg-native-test/ || echo "No backup files created"
          
          # If backup file exists, validate content
          if ls /tmp/pg-native-test/*.sql 2>/dev/null; then
            echo "=== Backup Content Validation ==="
            BACKUP_FILE=$(ls /tmp/pg-native-test/*.sql | head -1)
            echo "Analyzing: $BACKUP_FILE"
            cat "$BACKUP_FILE"
            echo ""
            echo "=== Content Checks ==="
            grep -c "native_test_users" "$BACKUP_FILE" && echo "✅ Found table references" || echo "❌ No table references"
            grep -c "native_active_users" "$BACKUP_FILE" && echo "✅ Found view definition" || echo "❌ No view definition" 
            grep -c "test_alice" "$BACKUP_FILE" && echo "✅ Found user data" || echo "❌ No user data"
            grep -c "native_test_seq" "$BACKUP_FILE" && echo "✅ Found sequence" || echo "❌ No sequence"
          else
            echo "❌ No backup files created - native engine failed"
            exit 1
          fi

      - name: Test MySQL Native Engine
        env:
          MYSQL_PWD: nativetest
        run: |
          echo "=== Setting up MySQL test data ==="
          mysql -h mysql-native -u root -pnativetest nativedb -e "
          CREATE TABLE native_test_orders (
              id INT AUTO_INCREMENT PRIMARY KEY,
              customer_name VARCHAR(100) NOT NULL,
              total DECIMAL(10,2),
              created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              notes TEXT,
              status ENUM('pending', 'processing', 'completed', 'cancelled') DEFAULT 'pending',
              is_priority BOOLEAN DEFAULT FALSE,
              binary_data VARBINARY(255)
          );
          INSERT INTO native_test_orders (customer_name, total, notes, status, is_priority, binary_data) VALUES
          ('Native Alice', 299.99, 'Test native engine', 'processing', TRUE, 0x4E617469766520546573742044617461),
          ('Native Bob', 89.50, NULL, 'completed', FALSE, NULL),
          ('Native Carol', 199.99, 'Binary data test', 'pending', TRUE, 0x54657374696E67204269636B); 
          
          CREATE VIEW native_priority_orders AS 
          SELECT customer_name, total, status FROM native_test_orders WHERE is_priority = TRUE;
          
          SELECT 'MySQL native test data created' as status;
          "
          
          echo "=== Testing Native MySQL Backup ==="
          mkdir -p /tmp/mysql-native-test
          MYSQL_PWD=nativetest ./dbbackup-native backup single nativedb \
            --db-type mysql \
            --host mysql-native \
            --port 3306 \
            --user root \
            --backup-dir /tmp/mysql-native-test \
            --native \
            --compression 0 \
            --no-config \
            --allow-root || true
            
          echo "=== Native MySQL Backup Results ==="
          ls -la /tmp/mysql-native-test/ || echo "No backup files created"
          
          # If backup file exists, validate content
          if ls /tmp/mysql-native-test/*.sql 2>/dev/null; then
            echo "=== MySQL Backup Content Validation ==="
            BACKUP_FILE=$(ls /tmp/mysql-native-test/*.sql | head -1)
            echo "Analyzing: $BACKUP_FILE"
            cat "$BACKUP_FILE"
            echo ""
            echo "=== Content Checks ==="
            grep -c "native_test_orders" "$BACKUP_FILE" && echo "✅ Found table references" || echo "❌ No table references"
            grep -c "native_priority_orders" "$BACKUP_FILE" && echo "✅ Found view definition" || echo "❌ No view definition"
            grep -c "Native Alice" "$BACKUP_FILE" && echo "✅ Found order data" || echo "❌ No order data"
            grep -c "0x" "$BACKUP_FILE" && echo "✅ Found binary data (hex)" || echo "❌ No binary data"
          else
            echo "⚠️  No MySQL backup files created - native engine may have failed (acceptable during development)"
          fi

      - name: Summary
        run: |
          echo "=== Native Engine Test Summary ==="
          echo "PostgreSQL Native: $(ls /tmp/pg-native-test/*.sql 2>/dev/null && echo 'SUCCESS' || echo 'FAILED')"
          echo "MySQL Native: $(ls /tmp/mysql-native-test/*.sql 2>/dev/null && echo 'SUCCESS' || echo 'PARTIAL/FAILED')"
          echo ""
          echo "This job validates our 'built our own machines' native database engines."
          echo "Failures here indicate issues with the pure Go implementations."

  lint:
    name: Lint
    runs-on: ubuntu-latest
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git checkout FETCH_HEAD

      - name: Install and run golangci-lint
        run: |
          go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.8.0
          golangci-lint run --timeout=5m ./...

  build-and-release:
    name: Build & Release
    runs-on: ubuntu-latest
    needs: [test, lint]
    if: startsWith(github.ref, 'refs/tags/v')
    container:
      image: golang:1.24-bookworm
    steps:
      - name: Checkout code
        env:
          TOKEN: ${{ github.token }}
        run: |
          apt-get update && apt-get install -y -qq git ca-certificates curl jq
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git init
          git remote add origin "https://${TOKEN}@git.uuxo.net/${GITHUB_REPOSITORY}.git"
          git fetch --depth=1 origin "${GITHUB_SHA}"
          git fetch --tags origin
          git checkout FETCH_HEAD

      - name: Build all platforms
        run: |
          mkdir -p release
          
          # Install cross-compilation tools for CGO
          apt-get update && apt-get install -y -qq gcc-aarch64-linux-gnu
          
          # Linux amd64 (with CGO for SQLite)
          echo "Building linux/amd64 (CGO enabled)..."
          CGO_ENABLED=1 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-linux-amd64 .
          
          # Linux arm64 (with CGO for SQLite)
          echo "Building linux/arm64 (CGO enabled)..."
          CC=aarch64-linux-gnu-gcc CGO_ENABLED=1 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o release/dbbackup-linux-arm64 .
          
          # Darwin amd64 (no CGO - cross-compile limitation)
          echo "Building darwin/amd64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-darwin-amd64 .
          
          # Darwin arm64 (no CGO - cross-compile limitation)
          echo "Building darwin/arm64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -ldflags="-s -w" -o release/dbbackup-darwin-arm64 .
          
          # FreeBSD amd64 (no CGO - cross-compile limitation)
          echo "Building freebsd/amd64 (CGO disabled)..."
          CGO_ENABLED=0 GOOS=freebsd GOARCH=amd64 go build -ldflags="-s -w" -o release/dbbackup-freebsd-amd64 .
          
          echo "All builds complete:"
          ls -lh release/

      - name: Create Gitea Release
        env:
          GITEA_TOKEN: ${{ github.token }}
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          
          echo "Creating Gitea release for ${TAG}..."
          echo "Debug: GITHUB_REPOSITORY=${GITHUB_REPOSITORY}"
          echo "Debug: TAG=${TAG}"
          
          # Simple body without special characters
          BODY="Download binaries for your platform"
          
          # Create release via API with simple inline JSON
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: token ${GITEA_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{"tag_name":"'"${TAG}"'","name":"'"${TAG}"'","body":"'"${BODY}"'","draft":false,"prerelease":false}' \
            "https://git.uuxo.net/api/v1/repos/${GITHUB_REPOSITORY}/releases")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY_RESPONSE=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Code: $HTTP_CODE"
          echo "Response: $BODY_RESPONSE"
          
          RELEASE_ID=$(echo "$BODY_RESPONSE" | jq -r '.id')
          
          if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
            echo "Failed to create release"
            exit 1
          fi
          
          echo "Created release ID: $RELEASE_ID"
          
          # Upload each binary
          echo "Files to upload:"
          ls -la release/
          
          for file in release/dbbackup-*; do
            FILENAME=$(basename "$file")
            echo "Uploading $FILENAME..."
            UPLOAD_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${GITEA_TOKEN}" \
              -F "attachment=@${file}" \
              "https://git.uuxo.net/api/v1/repos/${GITHUB_REPOSITORY}/releases/${RELEASE_ID}/assets?name=${FILENAME}")
            echo "Upload response: $UPLOAD_RESPONSE"
          done
          
          echo "Gitea release complete!"
          echo "GitHub mirror complete!"