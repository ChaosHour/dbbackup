package config

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// MyCnfCredentials holds credentials loaded from ~/.my.cnf
type MyCnfCredentials struct {
	User     string
	Password string
	Host     string
	Port     string
	Socket   string
}

// MyCnfSearchPaths returns the search paths for .my.cnf in priority order
func MyCnfSearchPaths() []string {
	var paths []string

	// 1. Current directory (project-local override)
	paths = append(paths, filepath.Join(".", ".my.cnf"))

	// 2. User's home directory (standard location)
	if home, err := os.UserHomeDir(); err == nil && home != "" {
		paths = append(paths, filepath.Join(home, ".my.cnf"))
	}

	// 3. System-wide
	paths = append(paths, "/etc/mysql/debian.cnf")

	return paths
}

// LoadMyCnf loads MySQL/MariaDB credentials from ~/.my.cnf
// Reads the [client] section which is used by mysql, mysqldump, etc.
// Search order: ./.my.cnf → ~/.my.cnf → /etc/mysql/debian.cnf
func LoadMyCnf() (*MyCnfCredentials, string, error) {
	for _, path := range MyCnfSearchPaths() {
		creds, err := LoadMyCnfFromPath(path)
		if err != nil {
			return nil, "", err
		}
		if creds != nil {
			return creds, path, nil
		}
	}
	return nil, "", nil // No .my.cnf found (not an error)
}

// LoadMyCnfFromPath reads MySQL credentials from a specific .my.cnf file.
// Parses the [client] section for user, password, host, port, socket.
func LoadMyCnfFromPath(path string) (*MyCnfCredentials, error) {
	f, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read %s: %w", path, err)
	}
	defer func() { _ = f.Close() }()

	creds := &MyCnfCredentials{}
	inClientSection := false
	found := false

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, ";") {
			continue
		}

		// Section header
		if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
			section := strings.ToLower(strings.Trim(line, "[]"))
			// [client] and [mysql] sections both contain connection credentials
			inClientSection = section == "client" || section == "mysql"
			continue
		}

		if !inClientSection {
			continue
		}

		// Key-value: support both "key=value" and "key = value"
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Strip surrounding quotes
		value = strings.Trim(value, "'\"")

		switch strings.ToLower(key) {
		case "user":
			creds.User = value
			found = true
		case "password":
			creds.Password = value
			found = true
		case "host":
			creds.Host = value
			found = true
		case "port":
			creds.Port = value
			found = true
		case "socket":
			creds.Socket = value
			found = true
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading %s: %w", path, err)
	}

	if !found {
		return nil, nil // File exists but no [client] credentials
	}

	return creds, nil
}

// SaveMyCnf writes MySQL/MariaDB credentials to ~/.my.cnf
// Creates or updates the [client] section. Preserves other sections.
func SaveMyCnf(creds *MyCnfCredentials) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("cannot determine home directory: %w", err)
	}
	return SaveMyCnfToPath(creds, filepath.Join(home, ".my.cnf"))
}

// SaveMyCnfToPath writes MySQL/MariaDB credentials to a specific path.
// If the file exists, replaces the [client] section while preserving others.
// Sets file permissions to 0600 (owner-only) for security.
func SaveMyCnfToPath(creds *MyCnfCredentials, path string) error {
	// Read existing content to preserve non-[client] sections
	var otherSections strings.Builder
	if data, err := os.ReadFile(path); err == nil {
		lines := strings.Split(string(data), "\n")
		inClientSection := false
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if strings.HasPrefix(trimmed, "[") && strings.HasSuffix(trimmed, "]") {
				section := strings.ToLower(strings.Trim(trimmed, "[]"))
				inClientSection = section == "client"
				if !inClientSection {
					otherSections.WriteString(line + "\n")
				}
				continue
			}
			if !inClientSection {
				otherSections.WriteString(line + "\n")
			}
		}
	}

	// Build new file content
	var sb strings.Builder
	sb.WriteString("# MySQL/MariaDB client credentials\n")
	sb.WriteString("# Auto-generated by dbbackup. Permissions: 0600 (owner-only).\n")
	sb.WriteString("# This file is read by mysql, mysqldump, mariadb, and dbbackup.\n\n")

	sb.WriteString("[client]\n")
	if creds.User != "" {
		sb.WriteString(fmt.Sprintf("user = %s\n", creds.User))
	}
	if creds.Password != "" {
		sb.WriteString(fmt.Sprintf("password = %s\n", creds.Password))
	}
	if creds.Host != "" {
		sb.WriteString(fmt.Sprintf("host = %s\n", creds.Host))
	}
	if creds.Port != "" {
		sb.WriteString(fmt.Sprintf("port = %s\n", creds.Port))
	}
	if creds.Socket != "" {
		sb.WriteString(fmt.Sprintf("socket = %s\n", creds.Socket))
	}
	sb.WriteString("\n")

	// Append preserved sections
	other := strings.TrimSpace(otherSections.String())
	if other != "" {
		sb.WriteString(other + "\n")
	}

	// Write with restrictive permissions (like .pgpass: owner-only)
	if err := os.WriteFile(path, []byte(sb.String()), 0600); err != nil {
		return fmt.Errorf("failed to write %s: %w", path, err)
	}

	return nil
}

// ApplyMyCnfCredentials loads ~/.my.cnf and applies credentials to Config.
// Only applies non-empty values (won't overwrite explicit CLI/env settings).
// Returns the path it was loaded from, or "" if none found.
func ApplyMyCnfCredentials(cfg *Config) string {
	creds, path, err := LoadMyCnf()
	if err != nil || creds == nil {
		return ""
	}

	if creds.User != "" && cfg.User == "root" {
		// Only override if user is still the default 'root'
		cfg.User = creds.User
	}
	if creds.Password != "" {
		cfg.Password = creds.Password
	}
	if creds.Host != "" && (cfg.Host == "localhost" || cfg.Host == "") {
		cfg.Host = creds.Host
	}
	if creds.Port != "" && cfg.Port == mysqlDefaultPort {
		if p, err := fmt.Sscanf(creds.Port, "%d", &cfg.Port); p == 0 || err != nil {
			_ = err // ignore invalid port in .my.cnf
		}
	}
	if creds.Socket != "" && cfg.Socket == "" {
		cfg.Socket = creds.Socket
	}

	return path
}
